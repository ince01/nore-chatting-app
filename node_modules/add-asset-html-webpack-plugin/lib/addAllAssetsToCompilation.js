"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function _path() {
    return data;
  };

  return data;
}

function _crypto() {
  const data = _interopRequireDefault(require("crypto"));

  _crypto = function _crypto() {
    return data;
  };

  return data;
}

function _pEachSeries() {
  const data = _interopRequireDefault(require("p-each-series"));

  _pEachSeries = function _pEachSeries() {
    return data;
  };

  return data;
}

function _micromatch() {
  const data = _interopRequireDefault(require("micromatch"));

  _micromatch = function _micromatch() {
    return data;
  };

  return data;
}

function _globby() {
  const data = _interopRequireDefault(require("globby"));

  _globby = function _globby() {
    return data;
  };

  return data;
}

var _handleUrl = _interopRequireDefault(require("./handleUrl"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function ensureTrailingSlash(string) {
  if (string.length && string.substr(-1, 1) !== '/') {
    return `${string}/`;
  }

  return string;
} // Copied from html-webpack-plugin


function resolvePublicPath(compilation, filename) {
  /* istanbul ignore else */
  const publicPath = typeof compilation.options.output.publicPath !== 'undefined' ? compilation.options.output.publicPath : _path().default.relative(_path().default.dirname(filename), '.'); // TODO: How to test this? I haven't written this logic, unsure what it does

  return ensureTrailingSlash(publicPath);
}

function resolveOutput(compilation, addedFilename, outputPath) {
  if (outputPath && outputPath.length) {
    /* eslint-disable no-param-reassign */
    compilation.assets[`${outputPath}/${addedFilename}`] = compilation.assets[addedFilename];
    delete compilation.assets[addedFilename];
    /* eslint-enable */
  }
}

function addFileToAssets(_x, _x2, _x3) {
  return _addFileToAssets.apply(this, arguments);
} // Visible for testing


function _addFileToAssets() {
  _addFileToAssets = _asyncToGenerator(function* (compilation, htmlPluginData, {
    filepath,
    typeOfAsset = 'js',
    includeRelatedFiles = true,
    hash = false,
    publicPath,
    outputPath,
    files = []
  }) {
    if (!filepath) {
      const error = new Error('No filepath defined');
      compilation.errors.push(error);
      return Promise.reject(error);
    }

    const fileFilters = Array.isArray(files) ? files : [files];

    if (fileFilters.length > 0) {
      const shouldSkip = !fileFilters.some(file => _micromatch().default.isMatch(htmlPluginData.outputName, file));

      if (shouldSkip) {
        return Promise.resolve(null);
      }
    }

    const addedFilename = yield htmlPluginData.plugin.addFileToAssets(filepath, compilation);
    let suffix = '';

    if (hash) {
      const md5 = _crypto().default.createHash('md5');

      md5.update(compilation.assets[addedFilename].source());
      suffix = `?${md5.digest('hex').substr(0, 20)}`;
    }

    const resolvedPublicPath = typeof publicPath === 'undefined' ? resolvePublicPath(compilation, addedFilename) : ensureTrailingSlash(publicPath);
    const resolvedPath = `${resolvedPublicPath}${addedFilename}${suffix}`;
    htmlPluginData.assets[typeOfAsset].unshift(resolvedPath);
    resolveOutput(compilation, addedFilename, outputPath);

    if (includeRelatedFiles) {
      const relatedFiles = yield (0, _globby().default)(`${filepath}.*`);
      yield Promise.all(relatedFiles.sort().map(
      /*#__PURE__*/
      function () {
        var _ref2 = _asyncToGenerator(function* (relatedFile) {
          const addedMapFilename = yield htmlPluginData.plugin.addFileToAssets(relatedFile, compilation);
          resolveOutput(compilation, addedMapFilename, outputPath);
        });

        return function (_x7) {
          return _ref2.apply(this, arguments);
        };
      }()));
    }

    return Promise.resolve(null);
  });
  return _addFileToAssets.apply(this, arguments);
}

function _default(_x4, _x5, _x6) {
  return _ref.apply(this, arguments);
}

function _ref() {
  _ref = _asyncToGenerator(function* (assets, compilation, htmlPluginData) {
    const handledAssets = yield (0, _handleUrl.default)(assets);
    yield (0, _pEachSeries().default)(handledAssets, asset => addFileToAssets(compilation, htmlPluginData, asset));
    return htmlPluginData;
  });
  return _ref.apply(this, arguments);
}

module.exports = exports.default;